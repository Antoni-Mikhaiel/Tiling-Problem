<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Domino Tiling Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800">
  <main class="max-w-4xl mx-auto p-6 w-full" style="top: 145px; position: relative;">
    <h1 class="text-3xl font-bold text-center mb-6" style="bottom: 150px; position: relative;">Domino Tiling Visualizer</h1>

    <div class="flex flex-wrap gap-12 justify-center mb-4">
      <select id="methodSelect" class="border p-2 rounded w-64 text-center">
        <option value="brute">Brute Force Backtracking (All Solutions)</option>
        <option value="divide">Divide and Conquer (2 x n count only)</option>
      </select>
    </div>

    <div class="flex flex-wrap gap-12 justify-center mb-4" id="dimensionInputs">
      <input type="number" id="rowsInput" placeholder="Rows" min="1" class="border p-2 rounded w-24 text-center" value="2" />
      <input type="number" id="colsInput" placeholder="Columns" min="1" class="border p-2 rounded w-24 text-center" value="4" />
      <input type="number" id="speedInput" placeholder="Speed (ms)" min="10" class="border p-2 rounded w-32 text-center" value="500" />
    </div>

    <div class="flex flex-wrap gap-2 justify-center mb-6">
      <button onclick="startVisualization()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow" id="startBtn">Start</button>
      <button onclick="togglePlayPause()" id="playPauseBtn" disabled class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Play</button>
      <button onclick="showPreviousTiling()" id="prevBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Previous</button>
      <button onclick="showNextTiling()" id="nextBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Next</button>
      <button onclick="restartVisualization()" id="restartBtn" disabled class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Restart</button>
    </div>

    <div id="grid" class="grid gap-1 justify-center"></div>
    <p id="counter" class="text-center mt-4 font-medium">Tiling count: 0</p>
    <p id="showingLabel" class="text-center font-medium mt-2"></p>
  </main>

  <script>
    // Global variables
    let rows = 2;
    let cols = 4;
    let grid = [];
    let solutions = [];
    let currentIndex = 0;
    let colorIndex = 0;
    const colors = [
      "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf",
      "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
      "#fffffc", "#d0f4de", "#fef9c3", "#fde2e4"
    ];
    let isPlaying = true; // Start as playing so animation runs immediately
    let animationSpeed = 500;
    let isVisualizationRunning = false;
    let pausePromiseResolve = null;

    const gridElement = document.getElementById("grid");
    const counterElement = document.getElementById("counter");
    const showingLabel = document.getElementById("showingLabel");
    const nextButton = document.getElementById("nextBtn");
    const prevButton = document.getElementById("prevBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const restartBtn = document.getElementById("restartBtn");
    const methodSelect = document.getElementById("methodSelect");
    const rowsInput = document.getElementById("rowsInput");
    const colsInput = document.getElementById("colsInput");
    const speedInput = document.getElementById("speedInput");
    const dimensionInputs = document.getElementById("dimensionInputs");

    // Divide and conquer tiling count (2 x n)
    function divideAndConquerTiling(n) {
      if (n === 0) return 1;
      if (n === 1) return 1;
      return divideAndConquerTiling(n - 1) + divideAndConquerTiling(n - 2);
    }

    // Enable/disable inputs based on method
    methodSelect.addEventListener("change", () => {
      if (methodSelect.value === "divide") {
        rowsInput.value = 2;
        rowsInput.disabled = true;
        colsInput.disabled = false;
        speedInput.disabled = true;
        playPauseBtn.disabled = true;
        nextButton.disabled = true;
        prevButton.disabled = true;
        restartBtn.disabled = true;
        showingLabel.textContent = "";
        counterElement.textContent = "Tiling count: 0";
        createGridDisplay(2, parseInt(colsInput.value || 1));
      } else {
        rowsInput.disabled = false;
        colsInput.disabled = false;
        speedInput.disabled = false;
        playPauseBtn.disabled = true;
        nextButton.disabled = true;
        prevButton.disabled = true;
        restartBtn.disabled = true;
        showingLabel.textContent = "";
        counterElement.textContent = "Tiling count: 0";
        createGridDisplay(parseInt(rowsInput.value || 2), parseInt(colsInput.value || 4));
      }
    });

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // New waitWhilePaused function to pause animation when paused
    async function waitWhilePaused() {
      while (!isPlaying) {
        await new Promise(resolve => (pausePromiseResolve = resolve));
      }
    }

    function createGridDisplay(r = rows, c = cols) {
      gridElement.innerHTML = "";
      gridElement.style.gridTemplateColumns = `repeat(${c}, 48px)`;
      gridElement.style.gridTemplateRows = `repeat(${r}, 48px)`;
      grid = [];

      for (let rr = 0; rr < r; rr++) {
        grid[rr] = [];
        for (let cc = 0; cc < c; cc++) {
          const cell = document.createElement("div");
          cell.className = "w-12 h-12 bg-gray-200 border border-gray-400 flex items-center justify-center text-xs rounded";
          cell.id = `cell-${rr}-${cc}`;
          grid[rr][cc] = false;
          gridElement.appendChild(cell);
        }
      }
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }

    function storeTiling(g) {
      const tiling = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] !== false) {
            const id = g[r][c];
            const index = tiling.findIndex(t => t.id === id);
            if (index >= 0) {
              tiling[index].cells.push([r, c]);
            } else {
              tiling.push({ id, cells: [[r, c]] });
            }
          }
        }
      }
      solutions.push(tiling);
    }

    // Backtracking with play/pause support
    async function placeDominoesBT(r, c, currentId) {
      while (r < rows && grid[r][c] !== false) {
        c++;
        if (c === cols) {
          c = 0;
          r++;
        }
      }

      if (r === rows) {
        storeTiling(cloneGrid(grid));
        return;
      }

      // Wait if paused before continuing
      await waitWhilePaused();

      if (c + 1 < cols && grid[r][c] === false && grid[r][c + 1] === false) {
        grid[r][c] = grid[r][c + 1] = currentId;
        highlightCells([[r, c], [r, c + 1]], getNextColor());
        await sleep(animationSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r][c + 1] = false;
        highlightCells([[r, c], [r, c + 1]], "#e5e7eb");
        await sleep(animationSpeed);
      }

      await waitWhilePaused();

      if (r + 1 < rows && grid[r][c] === false && grid[r + 1][c] === false) {
        grid[r][c] = grid[r + 1][c] = currentId;
        highlightCells([[r, c], [r + 1, c]], getNextColor());
        await sleep(animationSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r + 1][c] = false;
        highlightCells([[r, c], [r + 1, c]], "#e5e7eb");
        await sleep(animationSpeed);
      }
    }

    function getNextColor() {
      const color = colors[colorIndex % colors.length];
      colorIndex++;
      return color;
    }

    function highlightCells(cells, color = "") {
      for (const [r, c] of cells) {
        const cell = document.getElementById(`cell-${r}-${c}`);
        cell.style.backgroundColor = color || "#e5e7eb";
      }
    }

    function showTiling(index) {
      if (solutions.length === 0) return;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          document.getElementById(`cell-${r}-${c}`).style.backgroundColor = "#e5e7eb";
        }
      }

      const tiling = solutions[index];
      colorIndex = 0;
      tiling.forEach(tile => {
        const color = getNextColor();
        highlightCells(tile.cells, color);
      });

      counterElement.textContent = `Tiling count: ${solutions.length}`;
      showingLabel.textContent = `Showing: ${index + 1} of ${solutions.length}`;
    }

    function showNextTiling() {
      if (solutions.length === 0) return;
      currentIndex = (currentIndex + 1) % solutions.length;
      showTiling(currentIndex);
    }

    function showPreviousTiling() {
      if (solutions.length === 0) return;
      currentIndex = (currentIndex - 1 + solutions.length) % solutions.length;
      showTiling(currentIndex);
    }

    async function startVisualization() {
      const method = methodSelect.value;

      if (method === "divide") {
        cols = parseInt(colsInput.value);
        rows = 2;
        if (isNaN(cols) || cols <= 0) {
          alert("Please enter a valid positive integer for columns.");
          return;
        }
        const count = divideAndConquerTiling(cols);
        counterElement.textContent = `Number of ways to tile 2 x ${cols} grid: ${count}`;
        showingLabel.textContent = "";
        createGridDisplay(rows, cols);

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            document.getElementById(`cell-${r}-${c}`).style.backgroundColor = "#e5e7eb";
          }
        }

        playPauseBtn.disabled = true;
        nextButton.disabled = true;
        prevButton.disabled = true;
        restartBtn.disabled = true;

      } else {
        rows = parseInt(rowsInput.value);
        cols = parseInt(colsInput.value);

        if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
          alert("Please enter valid positive integers for rows and columns.");
          return;
        }

        animationSpeed = parseInt(speedInput.value);
        if (isNaN(animationSpeed) || animationSpeed < 10) {
          animationSpeed = 500;
          speedInput.value = animationSpeed;
        }

        solutions = [];
        currentIndex = 0;
        colorIndex = 0;
        isVisualizationRunning = true;
        isPlaying = true; // Start in play mode immediately
        pausePromiseResolve = null;

        createGridDisplay(rows, cols);

        playPauseBtn.disabled = false;
        nextButton.disabled = true;
        prevButton.disabled = true;
        restartBtn.disabled = false;
        playPauseBtn.textContent = "Pause";
        showingLabel.textContent = "Calculating all solutions... please wait.";
        counterElement.textContent = "Tiling count: 0";

        // Run backtracking with animation and play/pause
        await placeDominoesBT(0, 0, 1);

        if (!isVisualizationRunning) return;

        showingLabel.textContent = "";
        counterElement.textContent = `Tiling count: ${solutions.length}`;

        currentIndex = 0;
        showTiling(currentIndex);

        playPauseBtn.textContent = "Play";
        nextButton.disabled = false;
        prevButton.disabled = false;
      }
    }

    // Play/pause toggle during backtracking or viewing solutions
    function togglePlayPause() {
      if (!isVisualizationRunning && solutions.length === 0) return;

      isPlaying = !isPlaying;

      if (isPlaying) {
        playPauseBtn.textContent = "Pause";
        nextButton.disabled = true;
        prevButton.disabled = true;

        if (pausePromiseResolve) {
          pausePromiseResolve();
          pausePromiseResolve = null;
        }
      } else {
        playPauseBtn.textContent = "Play";
        nextButton.disabled = false;
        prevButton.disabled = false;
      }
    }

    function restartVisualization() {
      isVisualizationRunning = false;
      isPlaying = false;

      // Clear any waiting promise
      if (pausePromiseResolve) {
        pausePromiseResolve();
        pausePromiseResolve = null;
      }

      playPauseBtn.disabled = true;
      nextButton.disabled = true;
      prevButton.disabled = true;
      restartBtn.disabled = true;

      currentIndex = 0;
      solutions = [];
      colorIndex = 0;
      showingLabel.textContent = "";
      counterElement.textContent = "Tiling count: 0";

      // Clear the grid colors and grid state
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          grid[r][c] = false;
          const cell = document.getElementById(`cell-${r}-${c}`);
          if (cell) cell.style.backgroundColor = "#e5e7eb";
        }
      }
    }

    // Initialize grid display on page load
    createGridDisplay(rows, cols);
  </script>
</body>
</html>
