<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Domino Tiling Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800">
  <main class="max-w-4xl mx-auto p-6 w-full" style="top: 145px; position: relative;">
    <h1 class="text-3xl font-bold text-center mb-6" style="bottom: 150px; position: relative;">Domino Tiling Visualizer</h1>

      <div class="flex flex-wrap gap-7 justify-center mb-4">
      <input type="number" id="rowsInput" placeholder="Rows" min="1" class="border p-2 rounded w-24 text-center">
      <input type="number" id="colsInput" placeholder="Columns" min="1" class="border p-2 rounded w-24 text-center">
      <input type="number" id="speedInput" placeholder="Speed (ms)" min="0.1" class="border p-2 rounded w-32 text-center">
    </div>

    <div class="flex flex-wrap gap-4 justify-center mb-6">
      <button onclick="startVisualization()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow">Start</button>
      <button onclick="toggleAutoPlay()" id="autoBtn" disabled class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Start Auto</button>
      <button onclick="showPreviousTiling()" id="prevBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Previous</button>
      <button onclick="showNextTiling()" id="nextBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Next</button>
    </div>

    <div id="grid" class="grid gap-1 justify-center"></div>
    <p id="counter" class="text-center mt-4 font-medium">Tiling count: 0</p>
  </main>

  <script>
    let rows = 2;
    let cols = 4;
    let grid = [];
    let solutions = [];
    let currentIndex = 0;
    let autoInterval = null;
    let autoSpeed = 100;

    const gridElement = document.getElementById("grid");
    const counterElement = document.getElementById("counter");
    const nextButton = document.getElementById("nextBtn");
    const prevButton = document.getElementById("prevBtn");
    const autoBtn = document.getElementById("autoBtn");

    let colorIndex = 0;
    const colors = [
      "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf",
      "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
      "#fffffc", "#d0f4de", "#fef9c3", "#fde2e4"
    ];

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function createGridDisplay() {
      gridElement.innerHTML = "";
      gridElement.style.gridTemplateColumns = `repeat(${cols}, 48px)`;
      gridElement.style.gridTemplateRows = `repeat(${rows}, 48px)`;
      grid = [];

      for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.className = "w-12 h-12 bg-gray-200 border border-gray-400 flex items-center justify-center text-xs rounded";
          cell.id = `cell-${r}-${c}`;
          grid[r][c] = false;
          gridElement.appendChild(cell);
        }
      }
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }

    function storeTiling(g) {
      const tiling = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] !== false) {
            const id = g[r][c];
            const index = tiling.findIndex(t => t.id === id);
            if (index >= 0) {
              tiling[index].cells.push([r, c]);
            } else {
              tiling.push({ id, cells: [[r, c]] });
            }
          }
        }
      }
      solutions.push(tiling);
    }

    async function placeDominoesBT(r, c, currentId) {
      while (r < rows && grid[r][c] !== false) {
        c++;
        if (c === cols) {
          c = 0;
          r++;
        }
      }

      if (r === rows) {
        storeTiling(cloneGrid(grid));
        return;
      }

      if (c + 1 < cols && grid[r][c] === false && grid[r][c + 1] === false) {
        grid[r][c] = grid[r][c + 1] = currentId;
        highlightCells([[r, c], [r, c + 1]], getNextColor());
        await sleep(autoSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r][c + 1] = false;
        highlightCells([[r, c], [r, c + 1]], "#e5e7eb");
        await sleep(autoSpeed);
      }

      if (r + 1 < rows && grid[r][c] === false && grid[r + 1][c] === false) {
        grid[r][c] = grid[r + 1][c] = currentId;
        highlightCells([[r, c], [r + 1, c]], getNextColor());
        await sleep(autoSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r + 1][c] = false;
        highlightCells([[r, c], [r + 1, c]], "#e5e7eb");
        await sleep(autoSpeed);
      }
    }

    function getNextColor() {
      const color = colors[colorIndex % colors.length];
      colorIndex++;
      return color;
    }

    function highlightCells(cells, color = "") {
      for (const [r, c] of cells) {
        const cell = document.getElementById(`cell-${r}-${c}`);
        cell.style.backgroundColor = color || "#e5e7eb";
      }
    }

    function showTiling(index) {
      if (solutions.length === 0) return;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          document.getElementById(`cell-${r}-${c}`).style.backgroundColor = "#e5e7eb";
        }
      }

      const tiling = solutions[index];
      colorIndex = 0;
      tiling.forEach(tile => {
        const color = getNextColor();
        highlightCells(tile.cells, color);
      });

      counterElement.textContent = `Tiling count: ${solutions.length} | Showing ${index + 1}`;
    }

    function showNextTiling() {
      currentIndex = (currentIndex + 1) % solutions.length;
      showTiling(currentIndex);
    }

    function showPreviousTiling() {
      currentIndex = (currentIndex - 1 + solutions.length) % solutions.length;
      showTiling(currentIndex);
    }

    function toggleAutoPlay() {
      autoSpeed = parseInt(document.getElementById("speedInput").value);
      if (isNaN(autoSpeed) || autoSpeed < 100) autoSpeed = 1000;
      autoInterval = setInterval(showNextTiling, autoSpeed);
      autoBtn.disabled = true;
    }

   

    async function startVisualization() {
      rows = parseInt(document.getElementById("rowsInput").value);
      cols = parseInt(document.getElementById("colsInput").value);

      if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
        alert("Please enter valid positive integers for rows and columns.");
        return;
      }

      if ((rows * cols) % 2 !== 0) {
        alert("Impossible: odd number of cells!");
        return;
      }

      autoSpeed = parseInt(document.getElementById("speedInput").value);
      if (isNaN(autoSpeed) || autoSpeed < 50) autoSpeed = 500;

      currentIndex = 0;
      colorIndex = 0;
      solutions = [];
      createGridDisplay();
      await placeDominoesBT(0, 0, 1);
      showTiling(currentIndex);

      nextButton.disabled = prevButton.disabled = autoBtn.disabled = solutions.length === 0;
    }

    createGridDisplay();
  </script>
</body>
</html>