<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Domino Tiling Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-800">
  <main class="max-w-4xl mx-auto p-6 w-full" style="top: 145px; position: relative;">
    <h1 class="text-3xl font-bold text-center mb-6" style="bottom: 150px; position: relative;">Domino Tiling Visualizer</h1>

    <div class="flex flex-wrap gap-12 justify-center mb-4">
      <input type="number" id="rowsInput" placeholder="Rows" min="1" class="border p-2 rounded w-24 text-center" />
      <input type="number" id="colsInput" placeholder="Columns" min="1" class="border p-2 rounded w-24 text-center" />
      <input type="number" id="speedInput" placeholder="Speed (ms)" min="10" class="border p-2 rounded w-32 text-center" />
    </div>

    <div class="flex flex-wrap gap-2 justify-center mb-6">
      <button onclick="startVisualization()" id="startBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow">Start</button>
      
      <button onclick="toggleBacktrackingPlayPause()" id="playPauseBtn" disabled
        class="bg-yellow-400 hover:bg-yellow-500 text-white px-4 py-2 rounded shadow disabled:opacity-50">
        Pause
      </button>
      
      <button onclick="toggleAutoPlayStop()" id="autoPlayStopBtn" disabled
        class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded shadow disabled:opacity-50">
        Start Auto
      </button>

      <button onclick="showPreviousTiling()" id="prevBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Previous</button>
      <button onclick="showNextTiling()" id="nextBtn" disabled class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Next</button>
      
      <button onclick="restartVisualization()" id="restartBtn" disabled class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded shadow disabled:opacity-50">Restart</button>
    </div>

    <div id="grid" class="grid gap-1 justify-center"></div>
    <p id="counter" class="text-center mt-4 font-medium">Tiling count: 0</p>
    <p id="showing" class="text-center font-medium">Showing: -</p>
  </main>

  <script>
    let rows = 2;
    let cols = 4;
    let grid = [];
    let solutions = [];
    let currentIndex = 0;

    let isBacktracking = false;
    let shouldPause = false;
    let shouldStop = false;

    let autoInterval = null;
    let autoSpeed = 1000;

    const gridElement = document.getElementById("grid");
    const counterElement = document.getElementById("counter");
    const showingElement = document.getElementById("showing");
    const nextButton = document.getElementById("nextBtn");
    const prevButton = document.getElementById("prevBtn");
    const autoPlayStopBtn = document.getElementById("autoPlayStopBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const restartBtn = document.getElementById("restartBtn");
    const startBtn = document.getElementById("startBtn");

    let colorIndex = 0;
    const colors = [
      "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf",
      "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
      "#fffffc", "#d0f4de", "#fef9c3", "#fde2e4"
    ];

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function createGridDisplay() {
      gridElement.innerHTML = "";
      gridElement.style.gridTemplateColumns = `repeat(${cols}, 48px)`;
      gridElement.style.gridTemplateRows = `repeat(${rows}, 48px)`;
      grid = [];

      for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.className = "w-12 h-12 bg-gray-200 border border-gray-400 flex items-center justify-center text-xs rounded";
          cell.id = `cell-${r}-${c}`;
          grid[r][c] = false;
          gridElement.appendChild(cell);
        }
      }
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }

    function storeTiling(g) {
      const tiling = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (g[r][c] !== false) {
            const id = g[r][c];
            const index = tiling.findIndex(t => t.id === id);
            if (index >= 0) {
              tiling[index].cells.push([r, c]);
            } else {
              tiling.push({ id, cells: [[r, c]] });
            }
          }
        }
      }
      solutions.push(tiling);
    }

    async function placeDominoesBT(r, c, currentId) {
      if (shouldStop) return;

      while (r < rows && grid[r][c] !== false) {
        c++;
        if (c === cols) {
          c = 0;
          r++;
        }
      }

      if (r === rows) {
        storeTiling(cloneGrid(grid));
        return;
      }

      if (c + 1 < cols && grid[r][c] === false && grid[r][c + 1] === false) {
        grid[r][c] = grid[r][c + 1] = currentId;
        highlightCells([[r, c], [r, c + 1]], getNextColor());
        await waitWhilePaused();
        await sleep(autoSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r][c + 1] = false;
        highlightCells([[r, c], [r, c + 1]], "#e5e7eb");
        await waitWhilePaused();
        await sleep(autoSpeed);
      }

      if (r + 1 < rows && grid[r][c] === false && grid[r + 1][c] === false) {
        grid[r][c] = grid[r + 1][c] = currentId;
        highlightCells([[r, c], [r + 1, c]], getNextColor());
        await waitWhilePaused();
        await sleep(autoSpeed);
        await placeDominoesBT(r, c, currentId + 1);
        grid[r][c] = grid[r + 1][c] = false;
        highlightCells([[r, c], [r + 1, c]], "#e5e7eb");
        await waitWhilePaused();
        await sleep(autoSpeed);
      }
    }

    function getNextColor() {
      const color = colors[colorIndex % colors.length];
      colorIndex++;
      return color;
    }

    function highlightCells(cells, color = "") {
      for (const [r, c] of cells) {
        const cell = document.getElementById(`cell-${r}-${c}`);
        cell.style.backgroundColor = color || "#e5e7eb";
      }
    }

    function drawTiling(index) {
      if (index < 0 || index >= solutions.length) return;
      createGridDisplay();
      const tiling = solutions[index];
      colorIndex = 0;
      for (const { cells } of tiling) {
        const color = getNextColor();
        highlightCells(cells, color);
      }
      currentIndex = index;
      counterElement.textContent = `Tiling count: ${solutions.length}`;
      showingElement.textContent = `Showing: ${index + 1}`;
    }

    function showNextTiling() {
      if (solutions.length === 0) return;
      currentIndex = (currentIndex + 1) % solutions.length;
      drawTiling(currentIndex);
    }

    function showPreviousTiling() {
      if (solutions.length === 0) return;
      currentIndex = (currentIndex - 1 + solutions.length) % solutions.length;
      drawTiling(currentIndex);
    }

    function toggleAutoPlayStop() {
      if (autoInterval !== null) {
        // Stop auto play
        clearInterval(autoInterval);
        autoInterval = null;
        autoPlayStopBtn.textContent = "Start Auto";
        nextButton.disabled = false;
        prevButton.disabled = false;
        restartBtn.disabled = false;
      } else {
        // Start auto play
        let speedInputValue = parseInt(document.getElementById("speedInput").value);
        autoSpeed = isNaN(speedInputValue) || speedInputValue < 100 ? 1000 : speedInputValue;

        autoInterval = setInterval(showNextTiling, autoSpeed);
        autoPlayStopBtn.textContent = "Stop Auto";
        nextButton.disabled = true;
        prevButton.disabled = true;
        restartBtn.disabled = true;
      }
    }

    function toggleBacktrackingPlayPause() {
      if (!isBacktracking) return;

      if (shouldPause) {
        // Resume
        shouldPause = false;
        playPauseBtn.textContent = "Pause";
      } else {
        // Pause
        shouldPause = true;
        playPauseBtn.textContent = "Play";
      }
    }

    async function waitWhilePaused() {
      while (shouldPause && !shouldStop) {
        await sleep(100);
      }
    }

    async function startVisualization() {
      rows = parseInt(document.getElementById("rowsInput").value);
      cols = parseInt(document.getElementById("colsInput").value);

      if (isNaN(rows) || isNaN(cols) || rows <= 0 || cols <= 0) {
        alert("Please enter valid positive integers for rows and columns.");
        return;
      }

      if ((rows * cols) % 2 !== 0) {
        alert("Impossible: odd number of cells!");
        return;
      }

      let speedInputValue = parseInt(document.getElementById("speedInput").value);
      autoSpeed = isNaN(speedInputValue) || speedInputValue < 100 ? 1000 : speedInputValue;

      // Reset everything
      shouldStop = false;
      shouldPause = false;
      isBacktracking = true;
      solutions = [];
      currentIndex = 0;
      colorIndex = 0;
      createGridDisplay();
      counterElement.textContent = "Tiling count: 0";
      showingElement.textContent = "Showing: -";

      // Disable/Enable buttons accordingly
      startBtn.disabled = true;
      playPauseBtn.disabled = false;
      playPauseBtn.textContent = "Pause";
      autoPlayStopBtn.disabled = true;
      autoPlayStopBtn.textContent = "Start Auto";
      nextButton.disabled = true;
      prevButton.disabled = true;
      restartBtn.disabled = true;

      await placeDominoesBT(0, 0, 1);

      isBacktracking = false;
      startBtn.disabled = false;
      playPauseBtn.disabled = true;

      if (solutions.length > 0) {
        drawTiling(0);
        autoPlayStopBtn.disabled = false;
        nextButton.disabled = false;
        prevButton.disabled = false;
        restartBtn.disabled = false;
      } else {
        counterElement.textContent = "No solutions found.";
        showingElement.textContent = "Showing: -";
      }
    }

    function restartVisualization() {
      shouldStop = true;
      shouldPause = false;
      isBacktracking = false;
      if (autoInterval !== null) {
        clearInterval(autoInterval);
        autoInterval = null;
      }
      playPauseBtn.disabled = true;
      playPauseBtn.textContent = "Pause";
      autoPlayStopBtn.disabled = true;
      autoPlayStopBtn.textContent = "Start Auto";
      createGridDisplay();
      counterElement.textContent = "Tiling count: 0";
      showingElement.textContent = "Showing: -";
      solutions = [];
      currentIndex = 0;
      colorIndex = 0;
      startBtn.disabled = false;
      nextButton.disabled = true;
      prevButton.disabled = true;
      restartBtn.disabled = true;
    }

    // Initialize grid on page load
    createGridDisplay();
  </script>
</body>
</html>